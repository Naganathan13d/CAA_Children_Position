// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAStateCommand.cpp
// The state chart based command: TRAStateCommand
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAStateCommand.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
#include "CATFrmEditor.h"
#include "CATDocument.h"
#include "CATIDocRoots.h"
#include "CATIProduct.h"
#include "CATDocumentServices.h"
#include "CATIMovable.h"
#include "CATIModelEvents.h"
#include "CATModify.h"
#include "CATIRedrawEvent.h"
#include "CATBaseUnknown.h"






#include<iostream>
using namespace std;




CATCreateClass( TRAStateCommand);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TRAStateCommand::TRAStateCommand() :
  CATStateCommand ("TRAStateCommand", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  
{

	_spRootProduct = NULL_var;
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TRAStateCommand::~TRAStateCommand()
{
   
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TRAStateCommand::BuildGraph()
{

	CATFrmEditor * pEditor = NULL;

	pEditor = CATFrmEditor::GetCurrentEditor();
	if(!!pEditor)
	{
		CATDocument *  pDocument = pEditor->GetDocument();
		if(!!pDocument)
		{
			std::cout<<"doc is received" <<std::endl;
		}

	

	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDocument->QueryInterface(IID_CATIDocRoots,
		                      (void**) &piDocRootsOnDoc);

	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();

	std::cout << std::endl << " RootProducts List created " << std::endl ;	

	_spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
	CATIProduct *piProductOnRoot = NULL;
	rc = _spRootProduct->QueryInterface(IID_CATIProduct,
		                               (void**) &piProductOnRoot);

	std::cout << std::endl << " Got the Root Product " << std::endl ;


	// Get Children

	/* ---------------------------------------*/
	/* 3. Retrieves children under the root   */
	/* ---------------------------------------*/
	
	int nbOfDirectChidren = piProductOnRoot -> GetChildrenCount() ;
	cout << " Number of direct children under the root = " << nbOfDirectChidren << endl << flush;
	
	// then on a root product, get all the children agregated to it.
	CATListValCATBaseUnknown_var*   ListChildren =
		piProductOnRoot->GetAllChildren();
/** @anchor err_2 piProductOnRoot not set to NULL after release */ 
	piProductOnRoot -> Release();
	piProductOnRoot = NULL;
	if(NULL != ListChildren)
	{
		
		int numberOfChildren = ListChildren->Size();
		cout << " Number of all children under the root = " << numberOfChildren << endl << flush;

		/* -----------------------------------------------------------*/
		/*  4. For each child, get its partNumber, and InstanceName   */
		/* -----------------------------------------------------------*/
		CATIProduct_var spChild = NULL_var;
		for (int i=1;i<=numberOfChildren;i++)
		{
			spChild = (*ListChildren)[i];





	
    CATIMovable *piMovableOnInstance = NULL;
    rc = spChild -> QueryInterface (IID_CATIMovable,
                                            (void**) &piMovableOnInstance);
    

	CATMathTransformation absolutePosition;
	piMovableOnInstance -> GetAbsPosition(absolutePosition );

    double *aAbsoluteCoeff = new double [12];
	absolutePosition.GetCoef(aAbsoluteCoeff);	
	
	for ( int k=0; k<3; k++)
		std::cout << aAbsoluteCoeff[k] << " " << aAbsoluteCoeff[k+3]<< " " << aAbsoluteCoeff[k+6] << " " << aAbsoluteCoeff[k+9]<< std::endl;
/** @anchor err_3 aAbsoluteCoeff not set to NULL after delete */ 
	delete[] aAbsoluteCoeff;
	aAbsoluteCoeff = NULL;

	//RefreshVisuAndTree(spUnknown);

	// relative position in the context of the local product.
	// no specification for the context, means default movable will be used.
	CATIMovable_var spContext = NULL_var;
	CATMathTransformation relativePositon = 
		piMovableOnInstance -> GetPosition(spContext);
    double *aRelativeCoeff = new double [12];
	relativePositon.GetCoef(aRelativeCoeff);	
	std::cout << " Relative position of the instance in the context of the local product: " << std::endl;
	for ( k=0; k<3; k++)
		std::cout << aRelativeCoeff[k] << " " << aRelativeCoeff[k+3]<< " " << aRelativeCoeff[k+6] << " " << aRelativeCoeff[k+9]<< std::endl;
/** @anchor err_4 aRelativeCoeff not set to NULL after delete */ 
	delete[] aRelativeCoeff;
	aRelativeCoeff = NULL;

		}

	}

	}
 



	


}




HRESULT TRAStateCommand::AddExternalComponent(CATIProduct *iThisProd, CATDocument *iDocument, CATIProduct **oNewProduct)
{
	

	HRESULT rc = E_FAIL;
	
	if ( NULL != iDocument)
	{
		// Get RootProduct of the document to import.
		CATIDocRoots *piDocRootsOnDoc = NULL;
		rc = iDocument->QueryInterface(IID_CATIDocRoots,
			                           (void**) &piDocRootsOnDoc);
		if ( FAILED(rc) )
		{
			std::cout << "** QI on CATIDocRoots failed " << std::endl ;
			
		}
		
		CATListValCATBaseUnknown_var *pRootProducts = 
			piDocRootsOnDoc->GiveDocRoots();
		CATIProduct_var spRootProduct = NULL_var;
		if ( NULL != pRootProducts)
			if (pRootProducts->Size())
			{  
				// the root product is first element of
				// the list of root elements.
				spRootProduct = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			
		piDocRootsOnDoc->Release();
		piDocRootsOnDoc=NULL;
		
		CATIProduct_var spProduct = NULL_var;
		if (NULL_var != spRootProduct)
		{
		// We have the root product from which one
			// will be agregated in "this"
/** @anchor err_1 iThisProduct not tested before use */ 
		spProduct = iThisProd->AddProduct   (spRootProduct);
		}
		else
		{
			CATUnicodeString docName = iDocument-> StorageName();
/** @anchor err_2 iThisProduct not tested before use */ 
			iThisProd->AddShapeRepresentation(CATUnicodeString("model"),
				                              docName);
			
		}

		rc = spProduct->QueryInterface(IID_CATIProduct, 
			                           (void**) &*oNewProduct);
		
	}
	return rc; 
} 

void TRAStateCommand::RefreshVisuAndTree(CATBaseUnknown_var spUnknown)
{
	CATIModelEvents_var spEvents = spUnknown;

	CATModify ntfModify(spUnknown);

	spEvents->Dispatch(ntfModify);

	CATIRedrawEvent_var spRedraw = spUnknown;

	spRedraw->Redraw();
}